// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package standup

import (
	"github.com/sprintbot.io/sprintbot/pkg/domain"
	"sync"
	"time"
)

var (
	lockRunnerMockAnnounce   sync.RWMutex
	lockRunnerMockInProgress sync.RWMutex
	lockRunnerMockRun        sync.RWMutex
)

// RunnerMock is a mock implementation of Runner.
//
//     func TestSomethingThatUsesRunner(t *testing.T) {
//
//         // make and configure a mocked Runner
//         mockedRunner := &RunnerMock{
//             AnnounceFunc: func(teamID string, minutesBefore time.Duration)  {
// 	               panic("TODO: mock out the Announce method")
//             },
//             InProgressFunc: func(teamID string) bool {
// 	               panic("TODO: mock out the InProgress method")
//             },
//             RunFunc: func(teamID string, tz string, msgChan chan domain.StandUpMsg)  {
// 	               panic("TODO: mock out the Run method")
//             },
//         }
//
//         // TODO: use mockedRunner in code that requires Runner
//         //       and then make assertions.
//
//     }
type RunnerMock struct {
	// AnnounceFunc mocks the Announce method.
	AnnounceFunc func(teamID string, minutesBefore time.Duration)

	// InProgressFunc mocks the InProgress method.
	InProgressFunc func(teamID string) bool

	// RunFunc mocks the Run method.
	RunFunc func(teamID string, tz string, msgChan chan domain.StandUpMsg)

	// calls tracks calls to the methods.
	calls struct {
		// Announce holds details about calls to the Announce method.
		Announce []struct {
			// TeamID is the teamID argument value.
			TeamID string
			// MinutesBefore is the minutesBefore argument value.
			MinutesBefore time.Duration
		}
		// InProgress holds details about calls to the InProgress method.
		InProgress []struct {
			// TeamID is the teamID argument value.
			TeamID string
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// TeamID is the teamID argument value.
			TeamID string
			// Tz is the tz argument value.
			Tz string
			// MsgChan is the msgChan argument value.
			MsgChan chan domain.StandUpMsg
		}
	}
}

// Announce calls AnnounceFunc.
func (mock *RunnerMock) Announce(teamID string, minutesBefore time.Duration) {
	if mock.AnnounceFunc == nil {
		panic("RunnerMock.AnnounceFunc: method is nil but Runner.Announce was just called")
	}
	callInfo := struct {
		TeamID        string
		MinutesBefore time.Duration
	}{
		TeamID:        teamID,
		MinutesBefore: minutesBefore,
	}
	lockRunnerMockAnnounce.Lock()
	mock.calls.Announce = append(mock.calls.Announce, callInfo)
	lockRunnerMockAnnounce.Unlock()
	mock.AnnounceFunc(teamID, minutesBefore)
}

// AnnounceCalls gets all the calls that were made to Announce.
// Check the length with:
//     len(mockedRunner.AnnounceCalls())
func (mock *RunnerMock) AnnounceCalls() []struct {
	TeamID        string
	MinutesBefore time.Duration
} {
	var calls []struct {
		TeamID        string
		MinutesBefore time.Duration
	}
	lockRunnerMockAnnounce.RLock()
	calls = mock.calls.Announce
	lockRunnerMockAnnounce.RUnlock()
	return calls
}

// InProgress calls InProgressFunc.
func (mock *RunnerMock) InProgress(teamID string) bool {
	if mock.InProgressFunc == nil {
		panic("RunnerMock.InProgressFunc: method is nil but Runner.InProgress was just called")
	}
	callInfo := struct {
		TeamID string
	}{
		TeamID: teamID,
	}
	lockRunnerMockInProgress.Lock()
	mock.calls.InProgress = append(mock.calls.InProgress, callInfo)
	lockRunnerMockInProgress.Unlock()
	return mock.InProgressFunc(teamID)
}

// InProgressCalls gets all the calls that were made to InProgress.
// Check the length with:
//     len(mockedRunner.InProgressCalls())
func (mock *RunnerMock) InProgressCalls() []struct {
	TeamID string
} {
	var calls []struct {
		TeamID string
	}
	lockRunnerMockInProgress.RLock()
	calls = mock.calls.InProgress
	lockRunnerMockInProgress.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *RunnerMock) Run(teamID string, tz string, msgChan chan domain.StandUpMsg) {
	if mock.RunFunc == nil {
		panic("RunnerMock.RunFunc: method is nil but Runner.Run was just called")
	}
	callInfo := struct {
		TeamID  string
		Tz      string
		MsgChan chan domain.StandUpMsg
	}{
		TeamID:  teamID,
		Tz:      tz,
		MsgChan: msgChan,
	}
	lockRunnerMockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	lockRunnerMockRun.Unlock()
	mock.RunFunc(teamID, tz, msgChan)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//     len(mockedRunner.RunCalls())
func (mock *RunnerMock) RunCalls() []struct {
	TeamID  string
	Tz      string
	MsgChan chan domain.StandUpMsg
} {
	var calls []struct {
		TeamID  string
		Tz      string
		MsgChan chan domain.StandUpMsg
	}
	lockRunnerMockRun.RLock()
	calls = mock.calls.Run
	lockRunnerMockRun.RUnlock()
	return calls
}
