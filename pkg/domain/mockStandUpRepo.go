// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domain

import (
	"sync"
	"time"
)

var (
	lockStandUpRepoMockDelete           sync.RWMutex
	lockStandUpRepoMockDeleteAllForTeam sync.RWMutex
	lockStandUpRepoMockFindByTeam       sync.RWMutex
	lockStandUpRepoMockGenerateID       sync.RWMutex
	lockStandUpRepoMockGet              sync.RWMutex
	lockStandUpRepoMockList             sync.RWMutex
	lockStandUpRepoMockSaveUpdate       sync.RWMutex
)

// StandUpRepoMock is a mock implementation of StandUpRepo.
//
//     func TestSomethingThatUsesStandUpRepo(t *testing.T) {
//
//         // make and configure a mocked StandUpRepo
//         mockedStandUpRepo := &StandUpRepoMock{
//             DeleteFunc: func(id string) error {
// 	               panic("TODO: mock out the Delete method")
//             },
//             DeleteAllForTeamFunc: func(id string) error {
// 	               panic("TODO: mock out the DeleteAllForTeam method")
//             },
//             FindByTeamFunc: func(tid string) (*StandUp, error) {
// 	               panic("TODO: mock out the FindByTeam method")
//             },
//             GenerateIDFunc: func(teamID string, t time.Time) string {
// 	               panic("TODO: mock out the GenerateID method")
//             },
//             GetFunc: func(sid string) (*StandUp, error) {
// 	               panic("TODO: mock out the Get method")
//             },
//             ListFunc: func(teamID string) ([]*StandUp, error) {
// 	               panic("TODO: mock out the List method")
//             },
//             SaveUpdateFunc: func(s *StandUp) error {
// 	               panic("TODO: mock out the SaveUpdate method")
//             },
//         }
//
//         // TODO: use mockedStandUpRepo in code that requires StandUpRepo
//         //       and then make assertions.
//
//     }
type StandUpRepoMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(id string) error

	// DeleteAllForTeamFunc mocks the DeleteAllForTeam method.
	DeleteAllForTeamFunc func(id string) error

	// FindByTeamFunc mocks the FindByTeam method.
	FindByTeamFunc func(tid string) (*StandUp, error)

	// GenerateIDFunc mocks the GenerateID method.
	GenerateIDFunc func(teamID string, t time.Time) string

	// GetFunc mocks the Get method.
	GetFunc func(sid string) (*StandUp, error)

	// ListFunc mocks the List method.
	ListFunc func(teamID string) ([]*StandUp, error)

	// SaveUpdateFunc mocks the SaveUpdate method.
	SaveUpdateFunc func(s *StandUp) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ID is the id argument value.
			ID string
		}
		// DeleteAllForTeam holds details about calls to the DeleteAllForTeam method.
		DeleteAllForTeam []struct {
			// ID is the id argument value.
			ID string
		}
		// FindByTeam holds details about calls to the FindByTeam method.
		FindByTeam []struct {
			// Tid is the tid argument value.
			Tid string
		}
		// GenerateID holds details about calls to the GenerateID method.
		GenerateID []struct {
			// TeamID is the teamID argument value.
			TeamID string
			// T is the t argument value.
			T time.Time
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Sid is the sid argument value.
			Sid string
		}
		// List holds details about calls to the List method.
		List []struct {
			// TeamID is the teamID argument value.
			TeamID string
		}
		// SaveUpdate holds details about calls to the SaveUpdate method.
		SaveUpdate []struct {
			// S is the s argument value.
			S *StandUp
		}
	}
}

// Delete calls DeleteFunc.
func (mock *StandUpRepoMock) Delete(id string) error {
	if mock.DeleteFunc == nil {
		panic("StandUpRepoMock.DeleteFunc: method is nil but StandUpRepo.Delete was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	lockStandUpRepoMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockStandUpRepoMockDelete.Unlock()
	return mock.DeleteFunc(id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedStandUpRepo.DeleteCalls())
func (mock *StandUpRepoMock) DeleteCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStandUpRepoMockDelete.RLock()
	calls = mock.calls.Delete
	lockStandUpRepoMockDelete.RUnlock()
	return calls
}

// DeleteAllForTeam calls DeleteAllForTeamFunc.
func (mock *StandUpRepoMock) DeleteAllForTeam(id string) error {
	if mock.DeleteAllForTeamFunc == nil {
		panic("StandUpRepoMock.DeleteAllForTeamFunc: method is nil but StandUpRepo.DeleteAllForTeam was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	lockStandUpRepoMockDeleteAllForTeam.Lock()
	mock.calls.DeleteAllForTeam = append(mock.calls.DeleteAllForTeam, callInfo)
	lockStandUpRepoMockDeleteAllForTeam.Unlock()
	return mock.DeleteAllForTeamFunc(id)
}

// DeleteAllForTeamCalls gets all the calls that were made to DeleteAllForTeam.
// Check the length with:
//     len(mockedStandUpRepo.DeleteAllForTeamCalls())
func (mock *StandUpRepoMock) DeleteAllForTeamCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStandUpRepoMockDeleteAllForTeam.RLock()
	calls = mock.calls.DeleteAllForTeam
	lockStandUpRepoMockDeleteAllForTeam.RUnlock()
	return calls
}

// FindByTeam calls FindByTeamFunc.
func (mock *StandUpRepoMock) FindByTeam(tid string) (*StandUp, error) {
	if mock.FindByTeamFunc == nil {
		panic("StandUpRepoMock.FindByTeamFunc: method is nil but StandUpRepo.FindByTeam was just called")
	}
	callInfo := struct {
		Tid string
	}{
		Tid: tid,
	}
	lockStandUpRepoMockFindByTeam.Lock()
	mock.calls.FindByTeam = append(mock.calls.FindByTeam, callInfo)
	lockStandUpRepoMockFindByTeam.Unlock()
	return mock.FindByTeamFunc(tid)
}

// FindByTeamCalls gets all the calls that were made to FindByTeam.
// Check the length with:
//     len(mockedStandUpRepo.FindByTeamCalls())
func (mock *StandUpRepoMock) FindByTeamCalls() []struct {
	Tid string
} {
	var calls []struct {
		Tid string
	}
	lockStandUpRepoMockFindByTeam.RLock()
	calls = mock.calls.FindByTeam
	lockStandUpRepoMockFindByTeam.RUnlock()
	return calls
}

// GenerateID calls GenerateIDFunc.
func (mock *StandUpRepoMock) GenerateID(teamID string, t time.Time) string {
	if mock.GenerateIDFunc == nil {
		panic("StandUpRepoMock.GenerateIDFunc: method is nil but StandUpRepo.GenerateID was just called")
	}
	callInfo := struct {
		TeamID string
		T      time.Time
	}{
		TeamID: teamID,
		T:      t,
	}
	lockStandUpRepoMockGenerateID.Lock()
	mock.calls.GenerateID = append(mock.calls.GenerateID, callInfo)
	lockStandUpRepoMockGenerateID.Unlock()
	return mock.GenerateIDFunc(teamID, t)
}

// GenerateIDCalls gets all the calls that were made to GenerateID.
// Check the length with:
//     len(mockedStandUpRepo.GenerateIDCalls())
func (mock *StandUpRepoMock) GenerateIDCalls() []struct {
	TeamID string
	T      time.Time
} {
	var calls []struct {
		TeamID string
		T      time.Time
	}
	lockStandUpRepoMockGenerateID.RLock()
	calls = mock.calls.GenerateID
	lockStandUpRepoMockGenerateID.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *StandUpRepoMock) Get(sid string) (*StandUp, error) {
	if mock.GetFunc == nil {
		panic("StandUpRepoMock.GetFunc: method is nil but StandUpRepo.Get was just called")
	}
	callInfo := struct {
		Sid string
	}{
		Sid: sid,
	}
	lockStandUpRepoMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockStandUpRepoMockGet.Unlock()
	return mock.GetFunc(sid)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedStandUpRepo.GetCalls())
func (mock *StandUpRepoMock) GetCalls() []struct {
	Sid string
} {
	var calls []struct {
		Sid string
	}
	lockStandUpRepoMockGet.RLock()
	calls = mock.calls.Get
	lockStandUpRepoMockGet.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *StandUpRepoMock) List(teamID string) ([]*StandUp, error) {
	if mock.ListFunc == nil {
		panic("StandUpRepoMock.ListFunc: method is nil but StandUpRepo.List was just called")
	}
	callInfo := struct {
		TeamID string
	}{
		TeamID: teamID,
	}
	lockStandUpRepoMockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockStandUpRepoMockList.Unlock()
	return mock.ListFunc(teamID)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedStandUpRepo.ListCalls())
func (mock *StandUpRepoMock) ListCalls() []struct {
	TeamID string
} {
	var calls []struct {
		TeamID string
	}
	lockStandUpRepoMockList.RLock()
	calls = mock.calls.List
	lockStandUpRepoMockList.RUnlock()
	return calls
}

// SaveUpdate calls SaveUpdateFunc.
func (mock *StandUpRepoMock) SaveUpdate(s *StandUp) error {
	if mock.SaveUpdateFunc == nil {
		panic("StandUpRepoMock.SaveUpdateFunc: method is nil but StandUpRepo.SaveUpdate was just called")
	}
	callInfo := struct {
		S *StandUp
	}{
		S: s,
	}
	lockStandUpRepoMockSaveUpdate.Lock()
	mock.calls.SaveUpdate = append(mock.calls.SaveUpdate, callInfo)
	lockStandUpRepoMockSaveUpdate.Unlock()
	return mock.SaveUpdateFunc(s)
}

// SaveUpdateCalls gets all the calls that were made to SaveUpdate.
// Check the length with:
//     len(mockedStandUpRepo.SaveUpdateCalls())
func (mock *StandUpRepoMock) SaveUpdateCalls() []struct {
	S *StandUp
} {
	var calls []struct {
		S *StandUp
	}
	lockStandUpRepoMockSaveUpdate.RLock()
	calls = mock.calls.SaveUpdate
	lockStandUpRepoMockSaveUpdate.RUnlock()
	return calls
}
